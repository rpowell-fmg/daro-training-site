{
  "hash": "573b4e18b5938d9810fd17041a0b2d77",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Data Attributes\"\norder: 8\ntitle-slide-attributes:\n    data-background-gradient: linear-gradient(to top right, {{< brand color background >}}, {{< brand color pastelpink >}}, {{< brand color fmorange >}}, {{< brand color tangerine >}})\n\nformat: \n  revealjs:\n    margin: .15\n    quarto-required: \">= 1.6.0\"\n    width: 1600\n    height: 900\n    slide-number: \"c\"\n    css: ../styles.css\n    code-copy: true\n    echo: true\n    code-overflow: scroll\n---\n\n\n\n# Data types\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n## Data types in R\n\n- **logical**\n- **character**\n- **double**\n- **integer**\n\n## Logical & character\n\n::: {.column}\n**logical** - boolean values `TRUE` and `FALSE`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column}\n**character** - character strings\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(\"hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Double & integer\n\n::: {.column}\n**double** - floating point numerical values (default numerical type)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(1.335)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(7)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column}\n**integer** - integer numerical values (indicated with an `L`)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(7L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(1:3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Vectors\n\nVectors can be constructed using the `c()` function.\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, 2, 3)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\nc(\"Hello\", \"World!\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Hello\"  \"World!\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(c(\"hi\", \"hello\"), c(\"bye\", \"jello\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"hi\"    \"hello\" \"bye\"   \"jello\"\n```\n\n\n:::\n:::\n\n\n\n## Converting between types\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- 1:3\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n:::\n\n:::: {.column}\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.character(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\" \"2\" \"3\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"character\"\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n## Converting between types\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- c(TRUE, FALSE)\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1]  TRUE FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"logical\"\n```\n\n\n:::\n:::\n\n\n:::\n\n:::: {.column}\n::: {.fragment}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny <- as.numeric(x)\ny\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 0\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n## Converting between types\n\nR will happily convert between various types without complaint when different types of data are concatenated in a vector, and that's not always a great thing!\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1, \"Hello\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"1\"     \"Hello\"\n```\n\n\n:::\n\n```{.r .cell-code}\nc(FALSE, 3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0 3\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nc(1.2, 3L)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1.2 3.0\n```\n\n\n:::\n\n```{.r .cell-code}\nc(2L, \"two\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2\"   \"two\"\n```\n\n\n:::\n:::\n\n\n:::\n\n## Explicit vs. implicit coercion\n\nLet's give formal names to what we've seen so far:\n\n. . .\n\n- **Explicit coercion** is when you call a function like `as.logical()`, `as.numeric()`, `as.integer()`, `as.double()`, or `as.character()`\n\n. . .\n\n- **Implicit coercion** happens when you use a vector in a specific context that expects a certain type of vector\n\n\n## Special values\n\n- `NA`: Not available\n- `NaN`: Not a number\n- `Inf`: Positive infinity\n- `-Inf`: Negative infinity\n\n. . .\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npi / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n\n```{.r .cell-code}\n0 / 0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n:::\n\n\n:::\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1/0 - 1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] NaN\n```\n\n\n:::\n\n```{.r .cell-code}\n1/0 + 1/0\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] Inf\n```\n\n\n:::\n:::\n\n\n:::\n\n# Data classes\n\n## Data classes in R\n\n- **factor**\n- **datetime**\n- **data frame**\n- **list**\n\n# Factors\n\n## Factors\n\nR uses factors to handle categorical variables, variables that have a fixed and known set of possible values\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- factor(c(\"BS\", \"MS\", \"PhD\", \"MS\"))\nx\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] BS  MS  PhD MS \nLevels: BS MS PhD\n```\n\n\n:::\n:::\n\n\n\n. . .\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntypeof(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"integer\"\n```\n\n\n:::\n:::\n\n\n:::\n\n::: {.column}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclass(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"factor\"\n```\n\n\n:::\n:::\n\n\n::: \n\n. . .\n\nWe can think of factors like character (level labels) and an integer (level numbers) glued together\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglimpse(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n Factor w/ 3 levels \"BS\",\"MS\",\"PhD\": 1 2 3 2\n```\n\n\n:::\n\n```{.r .cell-code}\nas.integer(x)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 1 2 3 2\n```\n\n\n:::\n:::\n\n\n\n## Working with factors\n\n`handedness` variable in the cat lovers data shows everything imported as categorical\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat_lovers <- read_csv(\"../data/cat-lovers.csv\")\nglimpse(cat_lovers)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 60\nColumns: 3\n$ name           <chr> \"Bernice Warren\", \"Woodrow Stone\", \"Willie B…\n$ number_of_cats <chr> \"0\", \"0\", \"1\", \"3\", \"3\", \"2\", \"1\", \"1\", \"0\",…\n$ handedness     <chr> \"left\", \"left\", \"left\", \"left\", \"left\", \"lef…\n```\n\n\n:::\n:::\n\n\n\n## Working with factors - plotting\n\nKeeping `handedness` as a character outputs in *alphabetical* order\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nggplot(cat_lovers, mapping = aes(x = handedness)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](08_DataAttributes_files/figure-revealjs/plot-cat-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Use forcats to manipulate factors\n\nChanging `handedness` to a factor, outputs in *level* order\n\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code  code-line-numbers=\"2-4\"}\ncat_lovers %>%\n  mutate(handedness = \n           factor(handedness, \n                  level = c(\"left\", \"right\", \"ambidextrous\"))) %>%\n  ggplot(mapping = aes(x = handedness)) +\n  geom_bar()\n```\n\n::: {.cell-output-display}\n![](08_DataAttributes_files/figure-revealjs/plot-cat2-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n\n## Come for the functionality ...\n\n<br>\nstay for the logo\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](images/forcats-part-of-tidyverse.png)\n:::\n:::\n\n\n\n. . .\n\n- Factors are useful when you have true categorical data and you want to override the ordering of character vectors to improve display \n\n. . .\n\n- They are also useful in modeling scenarios \n\n. . .\n\n- The **forcats** package provides a suite of useful tools that solve common problems with factors\n\n\n## forcats functions\n\n:::: {.column}\n::: {.incremental}\n- `factor(x)` turns a vector into a factor vector\n    - default levels are alphabetical\n    - can set level order using `levels = ` argument\n- `levels(f)` returns the levels for a factor\n- `fct_count(f)` provides a count of the number of cases in each level\n- `fct_unify()` standardizes levels across a list of factors\n\n:::\n::::\n\n:::: {.column}\n::: {.incremental}\n- reorder factor levels:\n    - `fct_rev(f)` reverses the order of the levels\n    - `fct_infreq(f)` changes the level order based on frequency\n    - and many more\n- change factor levels:\n    - `fct_recode(f, d = \"a\", e = \"b\")` changes the levels manually\n    - `fct_collapse(f, d = c(\"a\", \"b\"))` collapses two or more levels into one\n    - and many more\n    \n:::\n::::\n\n::: {.footnote}\nSee [https://forcats.tidyverse.org/](https://forcats.tidyverse.org/) for more details\n:::\n\n# Dates\n\n## Dates\n\nTwo ways to handle dates\n\n::: column\n`as.Date()` from base R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny1 <- as.Date(\"2020-01-01\")\ny1\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y1)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n:::\n\n:::: column\n::: fragment\n**lubridate** from the tidyverse\n\n\n::: {.cell}\n\n```{.r .cell-code}\ny2 <- ymd(\"2020-01-01\")\ny2\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"2020-01-01\"\n```\n\n\n:::\n\n```{.r .cell-code}\ntypeof(y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"double\"\n```\n\n\n:::\n\n```{.r .cell-code}\nclass(y2)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Date\"\n```\n\n\n:::\n:::\n\n\n:::\n::::\n\n## lubridate\n\n::: {.column width=35%}\n\n\n::: {.cell layout-align=\"center\"}\n::: {.cell-output-display}\n![](images/lubridate-tidyverse.png){fig-align='center' width=80%}\n:::\n:::\n\n\n::: \n:::: {.column width=65%}\n::: {.incremental}\n- Create date/time variables from strings or numbers\n    - function name based on the order of the elements in the raw data\n    - `ymd()` looks for a date in year, month, day format\n    - `mdy()` looks for a date in month, day, year format\n    - `ymd_hms()` looks for a datetime in year, month, day, hour, minute, second format\n- Parse datetime components from a date/time variable\n    - `date()` will parse just the date component of a datetime variable\n    - `year()` and `hour()` will parse just the year and hour components\n\n:::\n::::\n\n::: {.notes}\n- delimiters are ingored when creating the variables: \"2025/07/10\" and \"20250710\" will both create a date variable without having to specify the delimiter\n:::\n\n## lubridate examples {.smaller}\n\n::: column\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"3,4\"}\nspss_ex %>% \n  filter(LastConnectionDate != \"\") %>% \n  mutate(LastDate_Formatted = \n           ymd(LastConnectionDate)) %>% \n  select(LastConnectionDate, LastDate_Formatted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 736 × 2\n   LastConnectionDate LastDate_Formatted\n   <chr>              <date>            \n 1 20250321           2025-03-21        \n 2 20250410           2025-04-10        \n 3 20250321           2025-03-21        \n 4 20250321           2025-03-21        \n 5 20250321           2025-03-21        \n 6 20250321           2025-03-21        \n 7 20250321           2025-03-21        \n 8 20250410           2025-04-10        \n 9 20250410           2025-04-10        \n10 20250410           2025-04-10        \n# ℹ 726 more rows\n```\n\n\n:::\n:::\n\n\n:::\n\n:::: column\n::: fragment\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"3,4\"}\nspss_ex %>% \n  filter(LastConnectionStartTime != \"\") %>% \n  mutate(LastStartTime_Formatted =\n           parse_date_time(LastConnectionStartTime, \"HMS\")) %>% \n  select(LastConnectionStartTime, LastStartTime_Formatted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 736 × 2\n   LastConnectionStartTime LastStartTime_Formatted\n   <chr>                   <dttm>                 \n 1 10:13:25                0000-01-01 10:13:25    \n 2 15:51:47                0000-01-01 15:51:47    \n 3 10:14:05                0000-01-01 10:14:05    \n 4 10:26:43                0000-01-01 10:26:43    \n 5 10:14:20                0000-01-01 10:14:20    \n 6 10:25:03                0000-01-01 10:25:03    \n 7 10:14:24                0000-01-01 10:14:24    \n 8 15:52:35                0000-01-01 15:52:35    \n 9 15:52:18                0000-01-01 15:52:18    \n10 15:52:28                0000-01-01 15:52:28    \n# ℹ 726 more rows\n```\n\n\n:::\n:::\n\n\n:::\n\n::: fragment\nNote that the output here shows a \"phantom\" date when only a time is provided\n:::\n::::\n\n## lubridate examples (cont.) {.smaller}\n\n\n\n::: {.cell}\n\n```{.r .cell-code  code-line-numbers=\"|2|3\"}\nspss_ex %>% \n  mutate(DateTime_Char = glue(\"{LastConnectionDate} {LastConnectionStartTime}\"),\n         LastDateTime_Formatted = ymd_hms(DateTime_Char)) %>% \n  filter(LastConnectionStartTime != \"\") %>% \n  select(LastConnectionDate, LastConnectionStartTime, \n         DateTime_Char, LastDateTime_Formatted)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 736 × 4\n   LastConnectionDate LastConnectionStartTime DateTime_Char    \n   <chr>              <chr>                   <glue>           \n 1 20250321           10:13:25                20250321 10:13:25\n 2 20250410           15:51:47                20250410 15:51:47\n 3 20250321           10:14:05                20250321 10:14:05\n 4 20250321           10:26:43                20250321 10:26:43\n 5 20250321           10:14:20                20250321 10:14:20\n 6 20250321           10:25:03                20250321 10:25:03\n 7 20250321           10:14:24                20250321 10:14:24\n 8 20250410           15:52:35                20250410 15:52:35\n 9 20250410           15:52:18                20250410 15:52:18\n10 20250410           15:52:28                20250410 15:52:28\n# ℹ 726 more rows\n# ℹ 1 more variable: LastDateTime_Formatted <dttm>\n```\n\n\n:::\n:::\n\n\n\n\n# Your turn: <br>Factors and date variables {background-gradient=\"linear-gradient(to bottom, #FFFFFF, #FFFFFF, #6BE1CA)\"}\n\n✋ if you have questions or need help\n\n`<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 512 512\" style=\"height:1em;width:1em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:currentColor;overflow:visible;position:relative;\"><path d=\"M123.6 391.3c12.9-9.4 29.6-11.8 44.6-6.4c26.5 9.6 56.2 15.1 87.8 15.1c124.7 0 208-80.5 208-160s-83.3-160-208-160S48 160.5 48 240c0 32 12.4 62.8 35.7 89.2c8.6 9.7 12.8 22.5 11.8 35.5c-1.4 18.1-5.7 34.7-11.3 49.4c17-7.9 31.1-16.7 39.4-22.7zM21.2 431.9c1.8-2.7 3.5-5.4 5.1-8.1c10-16.6 19.5-38.4 21.4-62.9C17.7 326.8 0 285.1 0 240C0 125.1 114.6 32 256 32s256 93.1 256 208s-114.6 208-256 208c-37.1 0-72.3-6.4-104.1-17.9c-11.9 8.7-31.3 20.6-54.3 30.6c-15.1 6.6-32.3 12.6-50.1 16.1c-.8 .2-1.6 .3-2.4 .5c-4.4 .8-8.7 1.5-13.2 1.9c-.2 0-.5 .1-.7 .1c-5.1 .5-10.2 .8-15.3 .8c-6.5 0-12.3-3.9-14.8-9.9c-2.5-6-1.1-12.8 3.4-17.4c4.1-4.2 7.8-8.7 11.3-13.5c1.7-2.3 3.3-4.6 4.8-6.9c.1-.2 .2-.3 .3-.5z\"/></svg>`{=html} when you are finished\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n\n```{=html}\n<div class=\"countdown\" id=\"timer_38a3e822\" data-update-every=\"1\" data-play-sound=\"true\" tabindex=\"0\" style=\"right:0;bottom:0;\">\n<div class=\"countdown-controls\"><button class=\"countdown-bump-down\">&minus;</button><button class=\"countdown-bump-up\">&plus;</button></div>\n<code class=\"countdown-time\"><span class=\"countdown-digits minutes\">15</span><span class=\"countdown-digits colon\">:</span><span class=\"countdown-digits seconds\">00</span></code>\n</div>\n```\n\n:::\n:::\n",
    "supporting": [
      "08_DataAttributes_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<link href=\"../site_libs/countdown-0.4.0/countdown.css\" rel=\"stylesheet\" />\n<script src=\"../site_libs/countdown-0.4.0/countdown.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}